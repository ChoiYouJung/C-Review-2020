Chapter1. C++시작
1.1 컴퓨터와 프로그래밍 그리고 C++
1) 소프트웨어와 컴퓨터
- 하드웨어(hardware) : 컴퓨터, 태블릿, 스마트폰 ... 등
- 소프트웨어(software) : 컴퓨터 하드웨어를 동작시켜 쇼핑을 하고 신문을 보고 음악을 듣고 게임을 할 수 있게하는 것
=> 프로그램 이라고도 한다.
- 소프트웨어는 CD나 DVD같은 저장매체로 제공되거나 인터넷에서 직접다운받는형태, 스마트폰에서 작동하는 APP을 인터넷앱 스토에서 사용자가 구매하는 형태로 제공된다.

2) 프로그래밍과 프로그래밍 언어
- 프로그래밍(programming) : 컴퓨터가 처리할 일련의 작업을 묘사하는 것
- 프로그래밍 언어(programming language) : 프로그래밍을 할 때, 사용하는 컴퓨터 언어
=> 여러가지가 존재한다.

- 컴퓨터의 두뇌인 CPU는 이진수(binary code)인 0과 1밖에 이해하지 못한다.

- 기계어(machine language) : 컴퓨터가 바로 이해하고 처리할 수 있는 0과 1만의 이진수를 사용하는 가장 원시적인 언어
- 기계어는 사람이 작성하기에는 매우 불편한 저수준 언어(low-level programming language)이다.

- 어셈블리어(assembly language) : 기계어 사용의 어려움을 해결하기 위해 0과 1로 구성되는 기계어의 각 명령어를 ADD, SUB, MOVE 등과 같이 사람이 표현하기 쉬운 상징적인 니모닉 기호(mnemonic symbol)로 일대일 대응시킨 언어
- 어셈블리어로 작성된 프로그램은 어셈블러(assembler)라고 부르는 시스템 프로그래밍에 의해 기계어 프로그램으로 변환되어 컴퓨터에서 실행된다.
- 그러나 어셈블리어 역시 사람이 다루기 힘든 저수준 언어로서 복잡한 구조의 프로그램 작성이나 다양한 형태의 자료를 표현하기에는 한계가 있다.

- 이에 사람이 이해하고 표현하기 쉬우며, 복잡한 알고리즘이나 다양한 프로그램 구조 및 자료를 효율적으로 표현할 수 있는 Fortran, Pascal, Basic, C/C++, C#, Java 등의 고급언어(high-level programming language)가 생겨나게 되었다.
- 고급 프로그래밍 언어로 작성된 프로그램은 컴파일러(compiler)라고 부르는 시스템 프로그램에 의해 기계어로 변환되어 컴퓨터에서 실행된다.
- 고급 프로그램은 어셈블리어로 먼저 변환되고 다시 기계어로 변환되는 두 단계의 변환 과정을 거친다.

<예시> C++로 프로그램 작성 -> 컴파일 -> 어셈블리어로 변환됨 -> 어셈블러가 어셈블한다 -> 기계어로 변환됨

3) 표준 C++프로그래밍의 중요성 
- 표준 C++규칙에 따라 작성된 프로그램은 어떤 컴파일러에 의해서도 컴파일되고 타겟 컴퓨터에서 동일하게 실행됨.
- 예를 들어 안되는 경우는 비주얼 C++만의 전용 키워드를 사용하여 작성한 프로그램은 비주얼 C++ 컴파일러에 의해서만 실행되며, 다른 컴파일러에 대해서는 컴파일되지 않는다.

1.2. C++언어의 특징 
1) C++언어의 설계 목표
(1)  C언어로 작성된 프로그램과의 호환성(compatability)을 유지
-> 기존에 작성된 C프로그램을 그대로 사용할 수 있도록 C언어의 문법적 체계를 그대로 계승한다.
-> 또한 C언어로 작성되어 컴파일된 목적 파일(object file)이나 라이브러리(library)를 C++프로그램에서 링크하여 사용할 수 있도록 한다.

(2) 소프트웨어의 재사용을 통해 소프트웨어 생산성을 증가시키고, 복잡하고 큰 규모의 소프트웨어 작성, 관리, 유지 보수를 쉽게 하기 위해 데이터 캡슐화, 상속, 다형성 등 객체 지향 개념을 도입한다.

(3) 타입체크를 엄격히 하여 실행시간 오류의 가능성을 줄이고 디버깅을 돕는다.

(4) 실행 시간의 효율성 저하를 최소화한다.
-> 객체 지향 개념의 도입으로 멤버함수의 호출이 잦아지고 이로 인해 발생하는 실행 시간 저하의 비효율성을 막기 위해 인라인 함수의 도입 등 함수호출로 인한 시간 저하를 막는다.

2) C언어의 추가한 기능

- C++언어는 C언어의 문법적 규칙을 그대로 승계하여, 프로그래밍의 편리와 다양성을 위해 다음과 같은 기능을 추가하였다.

(1) 인라인 함수(inline function) - 자주 호출되는 함수의 경우 함수 호출 대신 함수 코드를 확장 삽일하는 방식이며, 실행시간을 줄인다.
(2) 함수 중복(function overloading) - 매개변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있게 한다.
(3) 디폴트 매개 변수(default parameter) - 매개변수에 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있게 한다.
(4) 참조(reference)와 참조변수 - 변수에 별명을 붙여 변수 공간을 같이 사용할 수 있는 참조의 개념을 도입한다.
(5) 참조에 의한 호출(call-by-reference) - 함수 호출시 참조를 전달할 수 있게 한다.
(6) new와 delete 연산자 - 동적 메모리 할당, 해제를 위한 new,delete 연산자를 도입한다.
(7) 연산자 재정의(operator overloading) - 기존의 연산자에 새로운 연산을 정의할 수 있게 한다.
(8) 제네릭 함수와 클래스(generics) - 함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있게 한다.

3) C++의 객체 지향 특성
(1) 객체와 캡슐화(Encapsulation)
- 캡슐화는 데이터를 캡슐로 싸서 외부의 접근으로부터 데이터를 보호하는 객체 지향 특성이다.
- C++에서 캡슐의 역할을 하는 것이 클래스이며 class 키워드를 이용하여 작성한다.
- 클래스는 객체를 정의하는 틀이며, 객체는 클래스라는 틀에서 생겨난 실체(instance)이다.
- C++클래스는 멤버 변수들과 멤버 함수들로 이루어지며, 멤버들을 캡슐 외부에 공개하거나(public), 보이지 않게(private)선언할 수 있다.
- 공개된 멤버들만 외부 객체들이 접근 할 수 있다.
- C++프로그램 개발 시, 멤버 변수들으 외부에 보이지 않게(private) 선언하여 외부에 노출시키지 않는 것이 좋다.
- 대신 일부 멤버 함수들을 외부에 공개하여(public), 이 멤버함수를 통해서 멤버 변수에 간접적으로 접근하게 한다.

<예시 : 원 객체를 정의하는 C++ class >
class Circle{
   private:
      int radius;
   public:
      Circle(int r){ radius = r; }
      double getArea(){ return 3.14*radius*radius; }
};

(2) 상속성(Inheritance)
- C++에서 상속은 객체를 정의하는 클래스 사이에 상속관계를 두어, 자식 클래스의 객체가 생성될 때 자식 클래스에 선언된 멤버뿐 아니라 부모 클래스에 선언된 멤버들도 함께 가지고 탄생하게 한다.
- 상속은 구현된 코드의 재사용성을 높여서 소프트웨어 생산성을 높인다.

<상속관계 예시>
 class Phone{
   void call();
   void receive();
};

class MobilePhone : public Phone{
  void connectWireless();
  void recharge();
}

class MusicPhone : public MobilePhone{
  void downloadMusic();
  void play(); 
}

(3) 다형성(Polymorphism) - 동적인 특성
- 다형성은 하나의 기능이 경우에 따라 서로 다르게 보이거나 다르게 작동하는 현상을 말한다.
- 다형성의 예시 : 연산자 +
  2+3 -->5
  "남자" + "여자" --> "남자여자"
 redcolor 객체 + bluecolor 객체 --> purplecolor객체
  
=>이를 C++에서는 연산자 중복(operator overloading)이라고 부른다.

- 같은 이름의 함수가 매개 변수의 개수나 타입이 다르면 서로 다른 함수로 인식되는 함수 중복(function overloading)도 다형성의 하나이다.
(예시)
 void add(int a, int b){ ... }
 void add(int a, int b, int c){ ... }
 void add(int a, double d){ ... }

- C++에서 다형성은 상속 관계에서도 존재한다.
(예시) 
강아지, 고양이, 닭은 모두 동물 클래스의 속성을 상속받고, '소리내기' 함수를 강아지, 고양이, 닭에서 모두 서로 다르게 구현하였다.
이것은 부모클래스에 구현된 함수를 동일한 이름으로 자식 클래스에서 다르게 구현하는 함수 재정의 또는 함수 오버라이딩(overriding)으로 불린다.

4) C++언어에서 객체 지향 개념을 도입한 목적
- C++는 C, Pascal 등 기존의 절차지향언어가 가진 단점을 보완하고 다음과 같은 목적으로 객체 지향 개념을 도입하였다.
- 소프트웨어의 생산성 향상

- 실세계에 대한 쉬운 모델링

5) 절차 지형 프로그래밍과 객체 지향 프로그래밍

6) C++언어와 제네릭 프로그래밍
- 동일한 프로그램 코드에 다향한 데이터 타입을 적용할 수 있도록 함수와 클래스를 일반화시킨 제네릭 함수(generic fuction)와 제네릭 클래스(generic class)를 만들고,
  제네릭 함수와 제네릭 클래스에서 개발자가 원하는 데이터 타입을 적용시켜 프로그램 코드를 틀에서 찍어내는 듯이 생산하는 기법 == 제네릭 프로그래밍(generic programming)

- 2003년 ANSI C++ 표준에서 전격적으로 C++표준 라이브러리의 2/3를 제네릭으로 표준화하였다. 입출력 라이브러리를 과감하게 템플릿(template)으로 선언하여 제네릭화하고,
  응용프로그램 개발에 필요한 대부분의 자료 구조를 제네릭 함수와 제네릭 클래스로 구현한 STL(Standard Template Library)을 도입하여, 제네릭프로그래밍 시대를 출범시킴.

- 제네릭은 C++뿐 아니라 C#, Java등 다른 객체 지향언어에서도 이미 도입하여 사용하고 있다.

- 배워야 할 사항 : 제네릭 함수와 제네릭 클래스를 만들과 활용하는 방법
                        C++표준 STL라이브러리를 사용하는 방법
	           STL의 고급활용
7) C++의 아킬레스
- C++ 언어는 C코드와의 호환성이라는 중요한 목표로 설계되어 기존의 C코드를 재사용할 수 있게 되었지만, 그것으로 인해 객체 지향의 핵심 개념인 캡슐화의 원칙이 다소 무너졌다.
- 캡슐화의 기본 원칙은 코드와 데이터를 외부의 접근으로부터 보호하기 위해, 변수와 함수를 캡슐 즉 클래스 안에 선언하도록 하는 강력한 원칙이다.
- Java언어는 이 원칙을 굳건히 지키고 있지만, C++언어는 C언어로 작성된 프로그램을 수용하기 위해 함수 바깥에 전역 변수를 선언할 수 있는 C언어의 특성을 받아들일 수 밖에 없었다.
- 결국 이것때문에 C++에서 클래스라는 캡슐 바깥에 함수나 전역 변수를 만들 수 있게 허용하였으며, C프로그래밍에 있었던 전역 변수의 사용에 따른 부작용(side effect)이 여전히 존재하게 된다.

1.3. C++프로그램 개발 과정
C++소스 프로그램 작성 -> hell.cpp(소스파일) -> 컴파일 -> hello.obj(목적파일) -> 목적파일 + C++라이브러리를 링킹 -> hello.exe(실행파일) -> 실행 
***만약 실행파일 실행시 오류가 발생하면? 디버깅 -> 오류수정 -> 컴파일 -> 링킹 반복
1) C++ 소스 프로그램 작성
- 대부분의 컴파일 회사들이 C++소스 프로그램의 작성 및 편집, 컴파일, 링킹, 실행, 디버깅 등 C++ 프로그램 개발의 모든 단계를 지원하는 통합 개발 환경(Integrated Development Evironment)을 제공한다.
ex) Microsoft의 Visual C++(PC에서 사용되는 대표적인 통합 개발 소프트웨어)

2) 컴파일 (compile)
- C++소스프로그램 작성이 완료되면, C++컴파일러를 이용하여 C++소스 프로그램을 컴파일한다.
- C++ 컴파일러는 c++ 소스 프로그램이 문법에 맞게 작성되었는지 검사하고, 기계어 코드로 변환하여 목적파일(object)을 생성한다.
- 만약 문법에 맞지 않게 작성된 C++코드를 발견하면 컴파일 오류를 발생시킨다.
- 추가 ! 컴파일 시 기계어나 어셈블리어 코드 리스트 출력 결과 얻기
=> 비주얼 C++의 '프로젝트' 메뉴에서 속성 메뉴를 선택하여 속성 창을 출력하고, 이 창에서 '구성 속성/C/C++/출력파일/어셈블러 출력'메뉴를 차례로 선택하고, '어셈블리,기계어 코드, 소스(/FAcs)' 옵션을 선택한 후, 창을 닫고 나와서 프로젝트를 빌드하면 프로젝트 폴더의 Debug 폴더 안에 hello.cod 파일이 생성된다.
     이 파일은 텍스트 파일이므로 비주얼 C++에서 열어볼 수 있다.

3)링킹(linking)
- 컴파일 후 기계어로 구성된 목적 파일(object)이 생성되었다 하더라도 목적 파일은 바로 실행될 수 없다.
- why? 라이브러리나 다른 C++프로그램파일에 대한 참조 표시만 있고, 실제 코드는 포함하지 않고 있기 때문이다.
- 링킹은 어떤 목적 파일이 참조하는 C++표준 라이브러리나 다른 목적 파일 속에 있는 함수, 객체, 데이터를 포함하여 실행에 필요한 모든 기계어 코드를 확보하여, 하나의 실행파일로 만드는 과정
- 만약 링킹 과정 동안 목적 파일에서 참조하는 코드를 다른 목적 파일이나 라이브러리 속에서 발견할 수 없다면 링크 오류가 발생한다.
- 추가! 링킹과 DLL(Dynamic Linking Library)
=> 일반적으로 개발자가 작성한 C++소스와 이 소스에서 필요한 모든 라이브러리는 링킹 단계에서 완전히 결합되어 하나의 온전한 실행 파일이 만들어지며, 실행 시 이 실행 파일 외에 다른 코드는 필요 없다.
     하지만, 링킹 단계에서 결합하지 않고, 실행 중 필요한 순간에 결합하도록 만들어진 라이브러리가 있는데, 이것을 DLL이라한다.
     DLL은 실행 파일의 크기를 줄이는 역할과 함께 여러 응용프로그램이 실행 중에 공유하는 특징이 있다.

4) 프로그램 실행과 디버깅
- 링킹의 과정에 의해 생성된 실행 파일(exe 파일)은 컴퓨터에서 바로 실행 가능하다.
- 만약 프로그램에 논리적인 오류가 있다면, 실행 중 프로그램이 중단되거나 잘못된 결과를 내게 된다.
- 디버깅(Debugging) : 프로그램 내에 오류 위치를 발견하거나 문제의 원인을 찾아 수정하는 과정
- 디버깅은 일반적으로 디버거(debugger)라는 특별한 소프트웨어를 이용한다.
- 디버거는 C++프로그램을 라인 단위로 실행시키면서 변수 값의 변화를 관찰하거나, 원하는 소스 라인에 정지점(breakpoint)을 설정하여 프로그램이 정상적인 경로로 실행되는지 관찰하는 등 다양한 오류 수정 방법을 제공한다.
- 디버거는 일반적으로 컴파일러를 공급하는 회사에서 함께 공급한다.

5) C++프로그램의 확장자
- ANSI C++ 표준에서 C++소스 프로그램의 확장자는 .cpp이다. 컴파일러에 따라, .cxx, .c++, .cc, .C, .CC 등 다양한 확장자를 사용하고 있으므로, 해당 컴파일러의 매뉴얼을 참조할 필요가 있다. 목적 파일의 확장자 역시 운영체제에 따라 조금씩 다르다.
- 윈도우 운영체제에서는 .obj이며 유닉스 운영체제의 경우 .o를 사용한다.
- 실행파일의 경우, 윈도우 운영체제에서는 .exe이며 유닉스에서는 정해진 확장자가 없고 개발자가 마음대로 하면 된다.

1.4 C++표준라이브러리
1) 개발자들은 필요한 함수나 클래스를 새로 작성하기도 하지만, 이미 만들어진 함수나 클래스를 활용항 프로그램 개발에 걸리는 시간을 단축하고 프로그램의 확장성이나 정확성을 높인다. 

2) C++표준라이브러리
(1) 개발자들이 불러 쓸 수 있는 다양한 종류의 함수와 클래스가 컴파일된 목적 파일(object file)들이다.
(2) 이들 함수나 클래스 이름이 표준화되어 있기 때문에 C++표준 컴파일러 사이에 호환된다.
(3) C++ 표준 라이브러리는 컴파일된 목적 파일로만 제공되고, 원시 소스 코드는 공개되지 않는다.
(4) C++ 표준 라이브러리에 포함된 함수와 클래스는 수십 개의 헤더 파일에 분산되어있다.
(5) 크게 3그룹과 기타 기능으로 나눠짐.
- C 라이브러리 : 기존 C 표준 라이브러리를 수용하여 C++에서 사용할 수 있게 한 함수들
ex) cassert, ctype, cerrno cfloat, ciso646, climits, clocale, cmath, csetjmp, csignal, cstdio, cstdlib, cstring, ctime 등                      

- C++ 입출력 라이브러리 : 콘솔 및 파일 입출력을 위한 함수와 클래스들로서, 제네릭 프로그래밍을 지원하기 위한 템플릿으로 작성
ex) fstream, iomanip, ios, iosfwd, iostream, istream, ostream, sstream, strstream, streambuf

- C++ STL 라이브러리 : 제네릭 프로그래밍을 지원하기 위해 템플릿으로 작성된 유용한 함수와 클래스를 포함하는 라이브러리
ex) algorithm, bitset, complex, deque, exception, functional, iterator, limits, list, locale, map, memory, numeric, queue, set, stack, stdexcept, string, typeinfo, utility, valarray, vector 등

(6) <new>헤더 파일은 STL에 포함되지 않는 기타 기능은 구현함.  

